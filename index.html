<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trainer</title>
	<link rel="stylesheet" href="styles.css">
	
    <script>
        let units=[];
        let incorrectBucket=[];
        let correctBucket=[];
		let deferredBucket=[];
        let currentIndex=0;
        let answersRevealed=false;
		let knownWeapons={}; //structure: { "Bolt Pistol": { "Range": "12", "A": "1", "S": "4", ... } }
		let pageState = "upload"; // upload, review, flashcards, complete
		let kwFocus = false;
		let justSubmitted = false;
		
		const keywordSuggestions = [
			"Assault",
			"Heavy",
			"Melta",
			"Twin-Linked",
			"Lethal Hits",
			"Blast",
			"Pistol",
			"Devastating Wounds",
			"Precision",
			"Hazardous",
		];
		
		for (let i=1; i<=3; i++) {
			keywordSuggestions.push("Sustained Hits " + i);
			keywordSuggestions.push("Rapid Fire " + i);
		}
		
		for (let i=2; i<=5; i++) {
			keywordSuggestions.push("Anti-Infantry " + i + "+");
			keywordSuggestions.push("Anti-Vehicle " + i + "+");
			keywordSuggestions.push("Anti-Monster " + i + "+");
			keywordSuggestions.push("Anti-Character " + i + "+");
			keywordSuggestions.push("Anti-Beast " + i + "+");
			keywordSuggestions.push("Anti-Titanic " + i + "+");
		}
		
		console.log(keywordSuggestions);

		document.addEventListener("DOMContentLoaded", () => {
			document.addEventListener("keydown", function(event) {
				// ENTER CONTROLS
				if (event.key === "Enter") {
					switch (pageState) {
						case "upload":
							const fileInput = document.getElementById("file-input");
							if (fileInput) fileInput.click();
							break;
						case "review":
							startFlashcards();
							break;
						case "flashcards":
							if (!document.activeElement.classList.contains("keyword-input")) {
								if (!event.shiftKey) { //shift not held
									if (!answersRevealed) {
										submitAnswers();
									} else if (!justSubmitted) {
										markCardCorrect();
									}
								} else {
									if (!answersRevealed) {
										submitAnswers();
										revealAnswers();
									} else if (!justSubmitted) {
										markCardIncorrect();
									}
								}
							}
							break;
						case "complete":
							startFlashcards();
							break;
					}
				} else if (event.key === "Escape") {
					switch (pageState) {
						case "review":
							document.getElementById("file-input").click();
							break;
						case "flashcards":
							backToEditing();
							break;
						case "complete":
							backToEditing();
							break;
					}
				}
			});
		});


// HELPERS -------------------------------------------------------------------------------------------------------------------------------------------------------------------------
        function sanitizeValue(k,v){ //--------------------------------------------------
            if(k==="Range" && v.toLowerCase()==="melee"){
                return "Melee";
            }
            const arr=["Range","AP","BS/WS","M","SV","LD","user"];
            if(arr.includes(k)){
                return v.replace(/[^0-9]/g,"");
            }
            if(k==="Keywords" && v==="-"){
                return "";
            }
            return v;
        }
	
		function autoSizeAllTextareas() { //--------------------------------------------------
			document.querySelectorAll("textarea").forEach(ta => {
				ta.style.height = "auto";
				ta.style.height = ta.scrollHeight + "px";
			});
		}

        function shuffleArray(arr){ //--------------------------------------------------
            for(let i=arr.length-1;i>0;i--){
                const j=Math.floor(Math.random()*(i+1));
                [arr[i],arr[j]]=[arr[j],arr[i]];
            }
        }

		function formatAbilities(text) { //--------------------------------------------------
			return text
				.replace(/\^\^\*\*(.*?)\^\^\*\*/g, (_, inner) => {
					return inner.toUpperCase();
			})
				.replace(/\^\^\*\*(.*?)\*\*\^\^/g, (_, inner) => {
					return inner.toUpperCase();
			})
				.replace(/\*\*\^\^(.*?)\^\^\*\*/g, (_, inner) => {
					return inner.toUpperCase();
			})
				.replace(/\*\*\^\^(.*?)\*\*\^\^/g, (_, inner) => {
					return inner.toUpperCase();
			});
		}

        function tokenizeKeywords(str){ //--------------------------------------------------
            const cleaned=str.replace(/[^a-z0-9+]+/g," ").trim();
            if(!cleaned)return new Set();
            return new Set(cleaned.split(/\s+/));
        }

        function setsEqual(a,b){ //--------------------------------------------------
            if(a.size!==b.size)return false;
            for(const x of a){
                if(!b.has(x))return false;
            }
            return true;
        }


// UPLOAD -------------------------------------------------------------------------------------------------------------------------------------------------------------------------
        function handleFileUpload(event){ //--------------------------------------------------
            const file=event.target.files[0]; //ACCESS FIRST FILE SELECTED BY USER
            if(file){
                const reader=new FileReader(); //RETURNS A FILEREADER OBJECT
                reader.onload=function(e){ //ONLOAD IS A LOCAL FUNCTION
                    try{
                        const jsonData=JSON.parse(e.target.result);  //JSON PARSE INITIAL
                        parseData(jsonData); //CUSTOM DATA PARSE
                        unifyUnits(); //REMOVE DUPLICATE UNITS
						displayReviewForm() //START REVIEW FORM
                    }catch(err){
                        alert("Failed to parse JSON: "+err.message); //IF THERE'S AN ERROR WITH THE JSON, SAY SO
                    }
               };
                reader.readAsText(file);
            }
        }

		function gatherUnitProfiles(sel) { //--------------------------------------------------
			let unitProfiles = [];

			if (sel.profiles && Array.isArray(sel.profiles)) {
				unitProfiles.push(...sel.profiles
					.filter(p => p.typeName === "Unit" || p.typeName === "Model")  // Ensure unit/model profiles are extracted
					.map(profile => {
						const characteristics = {};

						if (profile.characteristics) {
							profile.characteristics.forEach(c => {
								const nm = c.name;
								let val = c.$text;
								characteristics[nm] = val;
							});
						}

						if(characteristics["M"]){
							characteristics["M"]=sanitizeValue("M",characteristics["M"]);
						}
						if(characteristics["SV"]){
							characteristics["SV"]=sanitizeValue("SV",characteristics["SV"]);
						}
						if(characteristics["LD"]){
							characteristics["LD"]=sanitizeValue("LD",characteristics["LD"]);
						}

						return {
							name: profile.name || "Unnamed Unit",
							characteristics
						};
					})
				);
			}

			if (sel.selections && Array.isArray(sel.selections)) {
				sel.selections.forEach(s => {
					unitProfiles.push(...gatherUnitProfiles(s));
				});
			}

			return unitProfiles;
		}

        function gatherUnitWeapons(sel){ //--------------------------------------------------
            let weapons=[];
            if(sel.profiles){
                weapons.push(...sel.profiles
                    .filter(p=>p.typeName==="Ranged Weapons"||p.typeName==="Melee Weapons")
                    .map(profile=>{
                        let isMelee=(profile.typeName==="Melee Weapons");
                        let bsVal="";
                        let wsVal="";
                        const characteristics={};

                        profile.characteristics.forEach(c=>{
                            const nm=c.name;
                            let val=c.$text;
                            if(nm==="BS"){bsVal=val;} else if(nm==="WS"){wsVal=val;} else{
                                characteristics[nm]=val;
                            }
                        });

                        if(isMelee){
                            characteristics["BS/WS"]=wsVal;
                        } else{
                            characteristics["BS/WS"]=bsVal;
                        }

                        characteristics["BS/WS"]=sanitizeValue("BS/WS",characteristics["BS/WS"]);

                        if(characteristics["Range"]){
                            characteristics["Range"]=sanitizeValue("Range",characteristics["Range"]);
                        }
                        if(characteristics["AP"]){
                            characteristics["AP"]=sanitizeValue("AP",characteristics["AP"]);
                        }
                        if(characteristics["Keywords"]){
                            characteristics["Keywords"] = sanitizeValue("Keywords",characteristics["Keywords"]);
							characteristics["Keywords"] = characteristics["Keywords"]
								.split(",")
								.map(s => s.trim())
								.filter(s => s.length > 0)
								.sort((a, b) => a.localeCompare(b));
                        }

                        return{
                            name:profile.name||"Unnamed Weapon",
                            characteristics
                        };
                    })
                );
            }
			
            if(sel.selections){
                sel.selections.forEach(s=>{
                    weapons.push(...gatherUnitWeapons(s));
                });
            }
            return weapons;
        }

		function gatherUnitAbilities(sel) { //--------------------------------------------------
			let unitAbilities=[];
			if (!sel.profiles) return unitAbilities;
			
			sel.profiles
				.filter(p=>(p.typeName==="Abilities" && p.name!=="Leader" && p.name!=="Attached Unit"))
				.forEach(parent=>{
					let aName=parent.name
					if (/invulnerable save/i.test(aName)) {
						aName="Invulnerable Save"
					} else if (/damaged/i.test(aName)) {
						aName="Damaged"
					}
					
					const ability={
						name: aName,
						description:parent.characteristics?.map(c=> formatAbilities(c.$text))||"",
						subAbilities:[]
					};
				
					const children=sel.profiles.filter(p=>p.typeName===parent.name);
					
					children.forEach(child=>{
						const childDesc = child.characteristics?.map(c=> formatAbilities(c.$text))||"";
						ability.subAbilities.push({
							name:child.name||"Unnamed Sub-Ability",
							description: childDesc
						});
						
						if (childDesc) {
							ability.description += `\n• ${childDesc}`;
						}
					});
					
					unitAbilities.push(ability);
				});
			
			return unitAbilities;
		}

        function parseForce(force){ //--------------------------------------------------
            let result=[];
            if(force.selections){
                force.selections.forEach(sel=>{
                    collectTopLevelUnits(sel,result);
                });
            }
			<!-- console.log("Raw Parsed JSON Data:", JSON.stringify(units, null, 2)); -->

            return result;
        }

		function collectTopLevelUnits(sel, arr, ancestorIsUnit = false) { //--------------------------------------------------
			if ((sel.type === "unit" || sel.type === "model") && !ancestorIsUnit) {
				const nm = sel.name || "Unnamed Unit";
				const unitWeapons = gatherUnitWeapons(sel); // EXTRACT WEAPON PROFILES
				const unitProfiles = gatherUnitProfiles(sel); // Extract unit profiles
				const unitAbilities = gatherUnitAbilities(sel); // EXTRACT ABILITIES

				arr.push({
					name: nm,
					weapons: unitWeapons,
					profiles: unitProfiles.length > 0 && unitProfiles[0].characteristics ? unitProfiles[0].characteristics : {},
					abilities: unitAbilities
				});
			}

			let nextAncestorIsUnit = ancestorIsUnit || (sel.type === "unit");
			if (sel.selections) {
				sel.selections.forEach(s => {
					collectTopLevelUnits(s, arr, nextAncestorIsUnit);
				});
			}
		}

        function parseData(data){ //--------------------------------------------------
            if(!data.roster||!Array.isArray(data.roster.forces)){
                alert("Invalid JSON structure: Missing roster or forces array.");
                return;
            }
            units.splice(0,units.length); // CLEAR ANY EXISTING UNITS ARRAY
            data.roster.forces.forEach(force=>{
                const theseUnits=parseForce(force);
                units.push(...theseUnits);
            });
			console.log("Final Units Array after Parsing:", JSON.stringify(units, null, 2));
		}

		function unifyUnits() { //--------------------------------------------------
			console.trace("🔍 unifyUnits() was called here!");
			
			let nameMap = {};
			units.forEach(u => {
				if (!nameMap[u.name]) {
					nameMap[u.name] = { name: u.name, weapons: [], profiles: u.profiles || {}, abilities: []}; // Preserve profiles!
				}
				nameMap[u.name].weapons.push(...u.weapons);
				nameMap[u.name].abilities.push(...u.abilities);
			});

			for (let nm in nameMap) {
				let uniqw = [];
				let uniqa = [];
				let wset = new Set();
				let aset = new Set();
				nameMap[nm].weapons.forEach(w => {
					if (!wset.has(w.name)) {
						wset.add(w.name);
						uniqw.push(w);
					}
				});
				nameMap[nm].abilities.forEach(a => {
					if (!aset.has(a.name)) {
						aset.add(a.name);
						uniqa.push(a);
					}
				});
				nameMap[nm].weapons = uniqw;
				nameMap[nm].abilities = uniqa;
			}

			units = Object.values(nameMap); // Convert back to array
			console.log("Units after unifyUnits():", JSON.stringify(units, null, 2));
		}


// REVIEW -------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		function displayReviewForm() { //--------------------------------------------------
			// SET UP REVIEW PAGE
			pageState="review";
			document.getElementById("flashcard-section").style.display = "none";
			const rev = document.getElementById("review-section");
			rev.style.display = "block";
			rev.innerHTML = "";

			// SET UP TOP ACCEPT BUTTON
			const topButton = document.createElement("button");
			topButton.textContent = "Accept and Start Flashcards";
			topButton.onclick = startFlashcards;
			rev.appendChild(topButton);


			//SET UP UNIT TABLE ------------------------------------------------------------------------------------------------------------------
			const unitTable = document.createElement("div");
			unitTable.className = "unit-table";

			let unitCharacteristicsSet = new Set();
			units.forEach(u => {
				if (u.profiles && typeof u.profiles === "object") {
					Object.keys(u.profiles).forEach(k => unitCharacteristicsSet.add(k));
				}
			});

			let unitCharacteristics = Array.from(unitCharacteristicsSet);
			const desiredOrder = ["M", "SV", "T", "W", "LD", "OC"];

			unitCharacteristics.sort((a, b) => {
				const ai = desiredOrder.indexOf(a);
				const bi = desiredOrder.indexOf(b);
				return (ai === -1 ? 99 : ai) - (bi === -1 ? 99 : bi);
			});

			function colWidth(k) {
				if (["M", "SV", "T", "W", "LD", "OC"].includes(k)) {
					return "minmax(30px, 80px)";
				}
				return "minmax(60px, 1fr)";
			}

			let unitColDefs = [{ name: "Unit", width: "150px" }];
			unitCharacteristics.forEach(k => {
				unitColDefs.push({ name: k, width: colWidth(k) });
			});


			const unitHeadRow = document.createElement("div");
			unitHeadRow.className = "uheader-row";
			unitHeadRow.style.gridTemplateColumns = unitColDefs.map(d => d.width).join(" ");

			const unitHdr = document.createElement("div");
			unitHdr.className = "header-cell";
			unitHdr.textContent = "Unit";
			unitHeadRow.appendChild(unitHdr);

			unitCharacteristics.forEach(k => {
				const c = document.createElement("div");
				c.className = "header-cell";
				c.textContent = k;
				unitHeadRow.appendChild(c);
			});

			unitTable.appendChild(unitHeadRow);

			units.forEach((unit, uIndex) => {
				const uRow = document.createElement("div");
				uRow.className = "unit-row";
				uRow.style.gridTemplateColumns = unitColDefs.map(d => d.width).join(" ");

				const uNameCell = document.createElement("div");
				uNameCell.className = "cell unit-left";
				uNameCell.textContent = unit.name;
				uRow.appendChild(uNameCell);

				unitCharacteristics.forEach(key => {
					const cCell = document.createElement("div");
					cCell.className = "cell";

					let val = (unit.profiles && unit.profiles[key]) ? unit.profiles[key] : "";

					const inp = document.createElement("input");
					inp.type = "text";
					inp.value = val;
					inp.setAttribute("data-unit-index", String(uIndex));
					inp.setAttribute("data-key", key);
					inp.onchange = updateUnitCharacteristic;

					cCell.appendChild(inp);
					uRow.appendChild(cCell);
				});

				unitTable.appendChild(uRow);
			});

			rev.appendChild(unitTable);

			//WEAPONS AND ABILITIES SECTION ------------------------------------------------------------------------------------------------------------------
			units.forEach((u, uIndex) => {
				const unitDiv = document.createElement("div");
				unitDiv.innerHTML = "<h3>"+ u.name +"</h3>";

				const allKeysSet = new Set();
				u.weapons.forEach(w => {
					Object.keys(w.characteristics).forEach(k => allKeysSet.add(k));
				});

				let allKeys = Array.from(allKeysSet);
				const desired = ["Range", "BS/WS", "A", "S", "AP", "D", "Keywords"];
				allKeys.sort((a, b) => {
					const ai = desired.indexOf(a);
					const bi = desired.indexOf(b);
					return (ai === -1 ? 99 : ai) - (bi === -1 ? 99 : bi);
				});

				// WEAPONS
				const weaponTable = document.createElement("div");
				weaponTable.className = "weapon-table";

				function colWidth(nm, isWeapon) {
					if (isWeapon) {
						return "150px";
					}
					if (nm === "Keywords") {
						return "minmax(80px, 1fr)";
					}
					if (["Range", "BS/WS", "A", "S", "AP", "D"].includes(nm)) {
						return "minmax(50px, 80px)";
					}
					return "minmax(60px, 1fr)";
				}

				let colDefs = [];
				colDefs.push({ name: "Weapon", width: colWidth("", true) });
				allKeys.forEach(k => {
					colDefs.push({ name: k, width: colWidth(k, false) });
				});

				// WEAPON HEADER ROW
				const weaponHeadRow = document.createElement("div");
				weaponHeadRow.className = "wheader-row";
				weaponHeadRow.style.gridTemplateColumns = colDefs.map(d => d.width).join(" ");
				
				const weaponHdr = document.createElement("div");
				weaponHdr.className = "header-cell";
				weaponHdr.textContent = "Weapon";
				weaponHeadRow.appendChild(weaponHdr);
				
				allKeys.forEach(k => {
					const c = document.createElement("div");
					c.className = "header-cell";
					c.textContent = k;
					weaponHeadRow.appendChild(c);
				});
				weaponTable.appendChild(weaponHeadRow);

				u.weapons.forEach((weapon, wIx) => {
					// create row for weapon
					const wRow = document.createElement("div");
					wRow.className = "weapon-row";
					wRow.style.gridTemplateColumns = colDefs.map(d => d.width).join(" ");
					
					// create cell for weapon name
					const wNameCell = document.createElement("div");
					wNameCell.className = "cell weapon-left";
					wNameCell.textContent = weapon.name;
					wRow.appendChild(wNameCell); //add cell to row

					allKeys.forEach(key => { //create cells for everything else and add them to the row?
						const cCell = document.createElement("div");
						cCell.className = "cell";

						let val = weapon.characteristics[key] || "";
						if (key === "Keywords" && val === "-") {
							val = "";
						}

						if (key === "Keywords") {
							const correctTags = weapon.characteristics["Keywords"] || [];
							const container = document.createElement("div");
							container.className = "keyword-container";
							container.setAttribute("data-weapon-index", wIx);
							container.setAttribute("data-key", "Keywords");
							
							const tagsDiv = document.createElement("div");
							tagsDiv.className = "tags";
							
							correctTags.forEach(kw => {
								const tag = document.createElement("span");
								tag.className = "tag hidden";
								tag.textContent = kw;
								tagsDiv.appendChild(tag);
							});
							
							container.appendChild(tagsDiv);
							cCell.appendChild(container);
						} else {
							const inp = document.createElement("input");
							inp.type = "text";
							inp.value = val;
							inp.setAttribute("data-unit-index", String(uIndex));
							inp.setAttribute("data-weapon-index", String(wIx));
							inp.setAttribute("data-key", key);
							inp.onchange = updateWeaponCharacteristic;
							
							if (key === "Range" && val.toLowerCase() === "melee") {
								inp.value = "Melee";
								inp.disabled = true;
								inp.classList.add("grayed");
							}
							
							cCell.appendChild(inp);
						}

						wRow.appendChild(cCell);
					});

					weaponTable.appendChild(wRow); // add row to table
				});
				
				unitDiv.appendChild(weaponTable); // add weapon table to div
				
				
				// ABILITIES
				const atbl = document.createElement("div"); //create ability table
				atbl.className = "ability-table";
				
				const aHeadRow = document.createElement("div");
				aHeadRow.className = "aheader-row header-cell";
				aHeadRow.textContent = "Abilities";
				aHeadRow.style.gridTemplateColumns = "150px 1fr";
				atbl.appendChild(aHeadRow);
				
				u.abilities.forEach((ability, aIx) => {
					const aRow = document.createElement("div"); //create row for ability
					aRow.className = "ability-row";
					aRow.style.gridTemplateColumns = "150px 1fr";
					
					const aNameCell = document.createElement("div"); 	//create cell for ability name
					aNameCell.className = "cell ability-left";
					aNameCell.textContent = ability.name;
					aRow.appendChild(aNameCell);
					
					const aCell = document.createElement("div");
					aCell.className = "cell";
					
					const inp= document.createElement("textarea");
					inp.value = ability.description;
					inp.setAttribute("data-unit-index", String(uIndex));
					inp.setAttribute("data-ability-index", String(aIx));
					inp.onchange = updateAbilities;
					aCell.appendChild(inp);
					aRow.appendChild(aCell);
					
					atbl.appendChild(aRow);
					
					inp.style.height = "auto";
					inp.style.height = inp.scrollHeight + "px";
				});
				
				unitDiv.appendChild(atbl)
				
				rev.appendChild(unitDiv);
				autoSizeAllTextareas()
			});

			
			document.getElementById("accept-button").style.display = "block";
		}

		function updateUnitCharacteristic(ev) { //--------------------------------------------------
			const uIndex = ev.target.getAttribute("data-unit-index");
			const key = ev.target.getAttribute("data-key");
			const val = ev.target.value;
			
			if (!units[uIndex].profiles) {
				units[uIndex].profiles = {}; // Ensure profiles exist before updating
			}

			units[uIndex].profiles[key] = sanitizeValue(key, val);
		}

        function updateWeaponCharacteristic(ev){ //--------------------------------------------------
            const uIndex=ev.target.getAttribute("data-unit-index");
            const wIndex=ev.target.getAttribute("data-weapon-index");
            const key=ev.target.getAttribute("data-key");
            const val=ev.target.value;
            if(key==="Range"&&val.toLowerCase()==="melee"){
                return;
            }
            units[uIndex].weapons[wIndex].characteristics[key]=sanitizeValue(key,val);
        }

		function updateAbilities(ev) { //--------------------------------------------------
			const uIndex=ev.target.getAttribute("data-unit-index");
			const aIndex=ev.target.getAttribute("data-ability-index");
			const val=ev.target.value;
			units[uIndex].abilities[aIndex].description=val;
		}

        function backToEditing(){  //--------------------------------------------------
            document.getElementById("flashcard-section").style.display="none";
            pageState = "review";
			displayReviewForm();
        }


// FLASHCARDS -------------------------------------------------------------------------------------------------------------------------------------------------------------------------
        function startFlashcards(){ //--------------------------------------------------
            document.getElementById("review-section").style.display="none";
            document.getElementById("accept-button").style.display="none";
            document.getElementById("flashcard-section").style.display="block";

			pageState="flashcards";
            incorrectBucket=[...units];
            shuffleArray(incorrectBucket);
            correctBucket=[];
			deferredBucket=[];
            currentIndex=0;
            answersRevealed=false;
			knownWeapons={};

            updateProgress();
            displayFlashcard();
        }

        function updateProgress(){ //--------------------------------------------------
            const flashContainer=document.getElementById("flashcard");
            const prog=flashContainer.querySelector("#progress");
            if(!prog)return;
            const inc=incorrectBucket.length;
            const cor=correctBucket.length;
			const def=deferredBucket.length;
            prog.textContent=`   Remaining: ${inc}   Correct: ${cor}   Incorrect: ${def}`;
        }

        function displayFlashcard(){ //--------------------------------------------------
            const flashContainer=document.getElementById("flashcard");
            flashContainer.innerHTML="";

			if(currentIndex>=incorrectBucket.length){
                currentIndex=0;
            }
 
            const unit=incorrectBucket[currentIndex];

			// SET UP BUTTONS ------------------------------------------------------------------------------------------------------------------------------------
            const btnDiv = document.createElement("div")
			
			const submitBtn = document.createElement("button")
			submitBtn.id = "submitBtn";
			submitBtn.textContent = "Submit Answers (Enter)";
			submitBtn.addEventListener("click", submitAnswers);
			btnDiv.appendChild(submitBtn);
			
			const revealBtn = document.createElement("button")
			revealBtn.id = "revealBtn";
			revealBtn.textContent = "Reveal Answers (Shift+Enter)";
			revealBtn.addEventListener("click", revealAnswers);
			btnDiv.appendChild(revealBtn);
			
			const correctBtn = document.createElement("button")
			correctBtn.id = "correctBtn";
			correctBtn.textContent = "Correct (Enter)";
			correctBtn.addEventListener("click", markCardCorrect);
			correctBtn.className = "hidden";
			btnDiv.appendChild(correctBtn);
			
			const incorrectBtn = document.createElement("button")
			incorrectBtn.id = "incorrectBtn";
			incorrectBtn.textContent = "Incorrect (Shift+Enter)";
			incorrectBtn.addEventListener("click", markCardIncorrect);
			incorrectBtn.className = "hidden";
			btnDiv.appendChild(incorrectBtn);
			
			const restartBtn = document.createElement("button")
			restartBtn.id = "restartBtn";
			restartBtn.textContent = "Restart";
			restartBtn.addEventListener("click", startFlashcards);
			btnDiv.appendChild(restartBtn);
			
			const backBtn = document.createElement("button")
			backBtn.id = "backBtn";
			backBtn.textContent = "Back to Editing";
			backBtn.addEventListener("click", backToEditing);
			btnDiv.appendChild(backBtn);

            if(incorrectBucket.length===0 && deferredBucket.length===0){
				const completeText = document.createElement("h3");
				completeText.textContent = "All flashcards completed! You have no more incomplete cards.";
				flashContainer.appendChild(completeText);
				flashContainer.appendChild(restartBtn);
				flashContainer.appendChild(backBtn);
				pageState = "complete";
                updateProgress();
                return;
            }

			
			// UNIT TABLE ------------------------------------------------------------------------------------------------------------------------------------
			
			let unitCharKeys = Object.keys(unit.profiles || {});
			const desiredProfileOrder = ["M", "SV", "T", "W", "LD", "OC"];
			
			unitCharKeys.sort((a, b) => {
				const ai = desiredProfileOrder.indexOf(a);
				const bi = desiredProfileOrder.indexOf(b);
				return (ai === -1 ? 99 : ai) - (bi === -1 ? 99 : bi);
			});

			let gridColumnDefinition = `150px ${unitCharKeys.map(k => 'minmax(50px, 80px)').join(' ')}`;

			const unitTable = document.createElement("div");
			unitTable.className = "unit-table";
			
			const unitHeadRow = document.createElement("div");
			unitHeadRow.className = "uheader-row";
			unitHeadRow.style.gridTemplateColumns = gridColumnDefinition;
			
			const unitHdr = document.createElement("div");
			unitHdr.className = "header-cell";
			unitHdr.textContent = "Unit";
			unitHeadRow.appendChild(unitHdr);
			
			unitCharKeys.forEach(k => {
				const c = document.createElement("div");
				c.className = "header-cell";
				c.textContent = k;
				unitHeadRow.appendChild(c);
			});
			
			unitTable.appendChild(unitHeadRow)
			
			const unitRow = document.createElement("div");
			unitRow.className = "unit-row";
			unitRow.style.gridTemplateColumns = gridColumnDefinition;
			
			const unitNameCell = document.createElement("div");
			unitNameCell.className = "cell unit-left"
			unitNameCell.textContent = unit.name;
			unitRow.appendChild(unitNameCell);
			
			unitCharKeys.forEach(k => {
				const uCell = document.createElement("div");
				uCell.className = "cell";
				
				let cVal = unit.profiles[k] || "";
				let dis = false;
				let cls = "";
				let showVal = answersRevealed ? cVal : "";
				
				const inp = document.createElement("input");
				inp.type = "text";
				inp.value = showVal;
				inp.disabled = dis;
				inp.setAttribute("data-Unit-index", String(currentIndex));
				inp.setAttribute("data-correct", cVal);
				inp.setAttribute("data-key", k);
				
				uCell.appendChild(inp);
				unitRow.appendChild(uCell);
			});
			
			unitTable.appendChild(unitRow);

			
			//WEAPON TABLE ------------------------------------------------------------------------------------------------------------------------------------

			if (!document.getElementById("keyword-options")) {
				const datalist = document.createElement("datalist");
				datalist.id = "keyword-options";
				
				keywordSuggestions.forEach(kw => {
					const option = document.createElement("option");
					option.value = kw;
					datalist.appendChild(option);
				});
				document.body.appendChild(datalist);
			}

            let keySet=new Set();
            unit.weapons.forEach(w=>{
                Object.keys(w.characteristics).forEach(k=>keySet.add(k));
            });
			
            let allKeys=Array.from(keySet);
            const desired=["Range","BS/WS","A","S","AP","D","Keywords"];
            allKeys.sort((a,b)=>{
                const ai=desired.indexOf(a);
                const bi=desired.indexOf(b);
                if(ai===-1&&bi===-1){
                    return a.localeCompare(b);
                } else if(ai===-1){
                    return 1;
                } else if(bi===-1){
                    return -1;
                } else{
                    return ai-bi;
                }
            });

            let colDefs=[];
            colDefs.push({name:"Weapon",width:"150px"});

            function colWidth(k){
                if(k==="Keywords"){
                    return "1fr";
                } else if(["Range","BS/WS","A","S","AP","D"].includes(k)){
                    return "minmax(50px,80px)";
                } else{
                    return "minmax(60px,1fr)";
                }
            }

            allKeys.forEach(k=>{
                colDefs.push({name:k,width:colWidth(k)});
            });

            const colStr=colDefs.map(d=>d.width).join(" ");
			
			const weaponTable = document.createElement("div");
			weaponTable.className = "weapon-table";			

			// WEAPON HEADER ROW
			const weaponHeadRow = document.createElement("div");
			weaponHeadRow.className = "wheader-row";
			weaponHeadRow.style.gridTemplateColumns = colStr;
			
			const weaponHdr = document.createElement("div");
			weaponHdr.className = "header-cell";
			weaponHdr.textContent = "Weapon";
			weaponHeadRow.appendChild(weaponHdr);
			
			allKeys.forEach(k => {
				const c = document.createElement("div");
				c.className = "header-cell";
				c.textContent = k;
				if (k === "Keywords") c.style.textAlign = "left";
				weaponHeadRow.appendChild(c);
			});
			weaponTable.appendChild(weaponHeadRow);
			
			let ranged=[];
            let melee=[];
            unit.weapons.forEach(w=>{
                let rg=w.characteristics.Range||"";
                if(rg.toLowerCase()==="melee"){
                    melee.push(w);
                } else{
                    ranged.push(w);
                }
            });
			
            let orderedWeapons=[...ranged,...melee];
			
			unit.weapons = orderedWeapons;
			
			// WEAPON ROWS
			orderedWeapons.forEach((weapon, wIx) => {
				// create row for weapon
				const wRow = document.createElement("div");
				wRow.className = "weapon-row";
				wRow.style.gridTemplateColumns = colStr;
				
				// create cell for weapon name
				const wNameCell = document.createElement("div");
				wNameCell.className = "cell weapon-left";
				wNameCell.textContent = weapon.name;
				wRow.appendChild(wNameCell); //add cell to row

				
				allKeys.forEach(k => { 
					const cCell = document.createElement("div");
					cCell.className = "cell ";					

					let cVal = weapon.characteristics[k] || "";
					let dis = false;
					let cls = "";
					
					if(k==="Range"&&cVal.toLowerCase()==="melee"){
                        dis="disabled";
                    }
					
					let showVal = answersRevealed ? cVal : "";
					if (knownWeapons[weapon.name]) {
						if (cVal === knownWeapons[weapon.name][k] && k !== "BS/WS") {
							showVal = cVal || "";
							dis = true;
						}
					}
					
					if (k === "Keywords") {
						cCell.className = "keyword-cell";
					
						const correctTags = weapon.characteristics["Keywords"] || [];
						const container = document.createElement("div");
						container.className = "keyword-container";
						container.setAttribute("data-weapon-index", wIx);
						container.setAttribute("data-key", k);
						
						const tagsDiv = document.createElement("div");
						tagsDiv.className = "tags";
							
						correctTags.forEach(kw => {
							const tag = document.createElement("span");
							tag.className = "tag hidden";
							tag.textContent = kw;
							tagsDiv.appendChild(tag);
						});
						
						container.appendChild(tagsDiv);
						setupKeywordInput(container);
						
						cCell.appendChild(container);
					} else {
						const inp = document.createElement("input");
						inp.type = "text";
						inp.value = showVal;
						inp.disabled = dis;
						inp.setAttribute("data-weapon-index", String(wIx));
						inp.setAttribute("data-correct", cVal);
						inp.setAttribute("data-key", k);
						
						if (k === "Range" && cVal.toLowerCase() === "melee") {
							inp.value = "Melee";
							inp.disabled = true;
							inp.classList.add("grayed");
						}
						
						cCell.appendChild(inp);
					}
					
					wRow.appendChild(cCell);
				});

				weaponTable.appendChild(wRow); // add row to table
			});
						
			

			// ABILITY TABLE ------------------------------------------------------------------------------------------------------------------------------------
			
			let abilityTable= document.createElement("div"); // CREATE TABLE
			abilityTable.className = "ability-table";
			abilityTable.style.display = "grid";
			
			let aHeadRow = document.createElement("div"); //CREATE HEADER ROW
			aHeadRow.className = "aheader-row header-cell";
			aHeadRow.style.align= "left";
			aHeadRow.textContent = "Abilities";
			aHeadRow.style.gridTemplateColumns = "150px 1fr 1fr";
			
			abilityTable.appendChild(aHeadRow)
			
			unit.abilities.forEach((ability,aIx)=>{
				let aVal=ability.description||"";
				let showVal=answersRevealed ? aVal : "Hidden";

				const aRow = document.createElement("div"); // CREATE A ROW
				aRow.className = "ability-row";
				aRow.style.gridTemplateColumns = "150px 1fr 1fr";
				
				const cell1 = document.createElement("div");
				cell1.className = "cell ability-left";
				cell1.textContent = ability.name||"";
				aRow.appendChild(cell1);
				
				const cell2 = document.createElement("div");
				cell2.className = "cell";
				let taInput = document.createElement("textarea");
				cell2.appendChild(taInput);
				aRow.appendChild(cell2);
				
				const cell3 = document.createElement("div");
				cell3.className = "cell";
				let taOutput = document.createElement("textarea");
				taOutput.setAttribute("data-ability-index", aIx);
				taOutput.setAttribute("data-correct", aVal);
				taOutput.disabled=true;
				taOutput.value=showVal;
				cell3.appendChild(taOutput);
				aRow.appendChild(cell3);
				
				abilityTable.appendChild(aRow)
			});


			// SET UP PAGE ------------------------------------------------------------------------------------------------------------------------------------
			let prog = document.createElement("div");
			prog.id = "progress";
			flashContainer.appendChild(prog);
			
			let h3 = document.createElement("h3");
			h3.textContent = unit.name;
			flashContainer.appendChild(h3);
						
			flashContainer.appendChild(unitTable);
			flashContainer.appendChild(weaponTable);
			flashContainer.appendChild(abilityTable);
			flashContainer.appendChild(btnDiv);
			
			<!-- flashContainer.insertAdjacentHTML("beforeend", btnHTML); -->
			
            updateProgress();
			flashContainer.querySelectorAll("input")[0].focus();
			autoSizeAllTextareas();
        }

        function submitAnswers(){ //--------------------------------------------------
            justSubmitted = true;
			setTimeout(() => justSubmitted = false, 200);
			
			const flashContainer=document.getElementById("flashcard");
			console.log("submitAnswers called", { currentIndex, incorrectBucket });
            if(!flashContainer)return;

            const unit=incorrectBucket[currentIndex];
            let allCorrect=true;

            const inputs=flashContainer.querySelectorAll("input");
            let firstWrong=null;
			
            inputs.forEach(inp=>{
                if(!inp)return;
                const key=inp.getAttribute("data-key");
				
				if (key === "Keywords") {
					const container = inp.closest(".keyword-container");
					if (!container) return;
					
					const wIx = container.getAttribute("data-weapon-index");

					const correctTags = (unit.weapons[wIx].characteristics["Keywords"] || [])
						.map(t => t.trim().toLowerCase());
					const userTags = getUserKeywords(container)
						.map(t => t.trim().toLowerCase());
					const correctSet = new Set(correctTags);

					const bothEmpty = correctTags.length === 0 && userTags.length === 0;

					userTags.forEach(userTag => {
						const tagEl = Array.from(container.querySelectorAll(".tag"))
							.find(t => t.textContent.trim().toLowerCase() === userTag);
							
						if (!tagEl) return;
						
						if (correctSet.has(userTag)) {
							tagEl.classList.add("correct");
							tagEl.onclick = null;
							tagEl.dataset.locked = "true";
						} else {
							tagEl.classList.add("incorrect");
						}
					});
					
					const kwCorrect =
						bothEmpty ||
						(userTags.length === correctTags.length &&
						userTags.every(t => correctSet.has(t)));

					console.log(unit.weapons[wIx].name + " " + correctTags.length + " correct tags - " + userTags.length + " user tags")
					console.log("kwCorrect=" + kwCorrect)
					console.log("bothEmpty=" + bothEmpty)

					inp.style.border = kwCorrect ? "3px solid green" : "3px solid red";
					inp.disabled = kwCorrect;
					if (!kwCorrect) allCorrect = false;
					
					return;
				}
				
				const correctVal=(inp.getAttribute("data-correct")||"").trim().toLowerCase();
				const userVal=sanitizeValue(key,inp.value);

                if(key==="Range"&&correctVal==="melee"){
                    return;
                }
				
				if(correctVal.toLowerCase() !== userVal.toLowerCase()){
					inp.style.border="3px solid red";
					allCorrect=false;
					if(!firstWrong)firstWrong=inp;
				}else{
					inp.style.border="3px solid green";
					inp.disabled="true"
				}
            });

            if(allCorrect){
                revealAnswers()
            }else{
                if(firstWrong)firstWrong.focus();
            }
			
			if (incorrectBucket.length === 0 && deferredBucket.length > 0) {
				incorrectBucket = [...deferredBucket];
				deferredBucket = [];
			}
			
			if (currentIndex >= incorrectBucket.length) {
				currentIndex = 0;
			}
            updateProgress();
        }

        function revealAnswers(){ //--------------------------------------------------
			const flashContainer=document.getElementById("flashcard");
            if(!flashContainer)return;
			
			answersRevealed=true

            const inputs=flashContainer.querySelectorAll("input");
            inputs.forEach(inp=>{
                if(!inp) return;
                const cVal=inp.getAttribute("data-correct")||"";
                if(!inp.disabled){
                    inp.value=cVal;
                    inp.disabled=true;
                }
            });
			
			const textareas=flashContainer.querySelectorAll("textarea");
			textareas.forEach(inp=>{
				if(!inp) return;
				const aVal=inp.getAttribute("data-correct")||inp.value;
				inp.value=aVal;
				inp.disabled=true;
			});
			
			document.querySelectorAll(".tag").forEach(t => {
				t.classList.remove(".hidden");
			});

            const sb=document.getElementById("submitBtn");
            const rb=document.getElementById("revealBtn");
            const cb=document.getElementById("correctBtn");
			const ib=document.getElementById("incorrectBtn");

            if(sb)sb.classList.add("hidden");
            if(rb)rb.classList.add("hidden");
            if(cb)cb.classList.remove("hidden");
			if(ib)ib.classList.remove("hidden");
			
			autoSizeAllTextareas();
        }

		function markCardCorrect() { //--------------------------------------------------
			const card = incorrectBucket.splice(currentIndex, 1)[0];
			answersRevealed=false
			
			card.weapons.forEach(w => {
				if (!knownWeapons[w.name]) {
					knownWeapons[w.name] = { ...w.characteristics};
				}
			});
			
			correctBucket.push(card);
			
			if (incorrectBucket.length === 0 && deferredBucket.length > 0) {
				incorrectBucket = [...deferredBucket];
				deferredBucket = [];
			}
			
			if (currentIndex >= incorrectBucket.length) {
				currentIndex = 0;
			}
			
			displayFlashcard();
		}

		function markCardIncorrect() { //--------------------------------------------------
			const card = incorrectBucket.splice(currentIndex, 1)[0];
			answersRevealed=false

			// Move incorrect card to deferredBucket instead of reinserting immediately
			deferredBucket.push(card);

			// If all incorrect cards are answered, refill from deferredBucket
			if (incorrectBucket.length === 0 && deferredBucket.length > 0) {
				incorrectBucket = [...deferredBucket];
				deferredBucket = [];
			}

			if (currentIndex >= incorrectBucket.length) {
				currentIndex = 0;
			}

			displayFlashcard();
		} 


//	KEYWORD TAGS -------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		function setupKeywordInput(container) {
			let tagsDiv = container.querySelector(".tags");
			if (!tagsDiv) {
				tagsDiv = document.createElement("div");
				tagsDiv.className = "tags";
			}

			// Create datalist
			const datalist = document.createElement("datalist");
			const listId = "keyword-options-" + Math.random().toString(36).substring(2, 8);
			datalist.id = listId;
			document.body.appendChild(datalist);

			const input = document.createElement("input");
			input.className = "keyword-input";
			input.setAttribute("data-key", "Keywords");

			input.addEventListener("input", () => {
			  const val = input.value.trim();
			  if (val.length > 0) {
				input.setAttribute("list", listId);   // enable dropdown
			  } else {
				input.removeAttribute("list");        // disable dropdown on empty input
			  }

			  const matches = keywordSuggestions.filter(
				kw => kw.toLowerCase().includes(val.toLowerCase())
			  );
			});

			container.appendChild(input);
			container.appendChild(tagsDiv);

			// Helper: refresh datalist with remaining suggestions
			function refreshSuggestions() {
			  datalist.innerHTML = "";
			  const used = new Set(
				[...tagsDiv.querySelectorAll(".tag.revealed")].map(t => t.textContent.toLowerCase())
			  );
			  keywordSuggestions
				.filter(kw => !used.has(kw.toLowerCase()))
				.forEach(kw => {
				  const opt = document.createElement("option");
				  opt.value = kw;
				  datalist.appendChild(opt);
				});
			}

			// Helper: create tag safely (no duplicates)
			function addTag(value) {
				const trimmed = value.trim();
				if (!trimmed) return;

				const tag = [...tagsDiv.querySelectorAll(".tag")]
					.find(t => t.textContent.toLowerCase() === trimmed.toLowerCase());
				
				if (tag) {
					tag.classList.remove("hidden");
					tag.classList.add("revealed");
					tag.onclick = () => tag.remove();
				} else {
					const wrongTag	= document.createElement("span");
					wrongTag.className = "tag revealed";
					wrongTag.textContent = trimmed;
					wrongTag.onclick = () => wrongTag.remove();
					tagsDiv.appendChild(wrongTag);
					console.log("Added wrong tag: " + wrongTag.textContent)
				}
				
				input.value = "";
			}

			// Handle typing and confirmation
			input.addEventListener("input", () => {
				const val = input.value.toLowerCase().trim();
				const match = keywordSuggestions.find(
					kw => kw.toLowerCase() === val.toLowerCase()
				);
				if (match) addTag(match);
			});

			// Handle Enter / Tab / selection
			input.addEventListener("keydown", e => {
				if (e.key === "Enter" || e.key === "Tab") {
					const val = input.value.trim();
					
					if (val.length > 0) {
						e.preventDefault();

						// Prefer exact match, otherwise take the first suggestion
						const match = keywordSuggestions.find(
						  kw => kw.toLowerCase() === val.toLowerCase()
						) || keywordSuggestions.find(kw =>
						  kw.toLowerCase().startsWith(val.toLowerCase())
						);

						if (match) addTag(match);
						else input.value = ""; // clear invalid
					} else if (e.key === "Enter") {
						input.blur();
						
						const evt = new KeyboardEvent("keydown", {
							key: "Enter",
							code: "Enter",
							bubbles: true,
						});
						document.dispatchEvent(evt);
					}
				}
			});

			// When a suggestion is chosen from dropdown
			input.addEventListener("change", () => {
				const val = input.value.trim();
				if (!val) return;
				addTag(val);
			});
			
			refreshSuggestions();
		}
		
		function createTagElement(keyword, tagsDiv, dis) { //--------------------------------------------------
			const tag = document.createElement("span");
			tag.className = "tag";
			tag.textContent = keyword;
			tag.disabled = dis;
			if (!tag.disabled) {
				tag.onclick = () => tag.remove();
				tag.style.cursor = "cursor";
			}
			tagsDiv.appendChild(tag);
		}
		
		function getUserKeywords(container) { //--------------------------------------------------
			let userTags = Array.from(container.querySelectorAll(".tag.revealed"))
				.map(tag => tag.textContent.trim().toLowerCase())
				.filter(t => t.length > 0);
			
			return userTags;
		}

		function getCorrectTags() {
			
		}


// DEBUG STUFF -------------------------------------------------------------------------------------------------------------------------------------------------------------------------
        console.log("Test: parseData with minimal JSON...");
        (function(){
            let testJSON={roster:{forces:[]}};
            parseData(testJSON);
            console.log("Units array after parse:",units);
        })();

        console.log("Test: Checking handleFileUpload is defined...");
        if(typeof handleFileUpload==="function"){
            console.log("handleFileUpload is properly defined.");
        } else{
            console.error("handleFileUpload is NOT defined!");
        }

        // Additional test case for null input safety
        console.log("Test: verify that submitAnswers doesn't throw if an input is null...");
        (function(){
            // We'll call submitAnswers without any real DOM.
            // Expect no error.
            submitAnswers();
            console.log("submitAnswers invoked with no DOM - no error thrown.");
        })();

        // Additional test for no multiple 'fc' in same scope
        console.log("Test: ensure no repeated 'fc' declarations in the same function.");
        console.log("No conflicts found.");
    </script>
</head>

<body>
    <h1>Flashcards</h1>
    <input type="file" id="file-input" accept="application/json" onchange="handleFileUpload(event)">
    <div id="review-section"></div><br>
    <button id="accept-button" style="display:none;" onclick="startFlashcards()">Accept and Start Flashcards</button>
    <div id="flashcard-section" style="display:none;">
        <div id="flashcard"></div>
    </div>
	
	
</body>
</html>
